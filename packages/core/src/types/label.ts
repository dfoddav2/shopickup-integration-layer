/**
 * Label generation response types
 * Carrier-agnostic types for batch label creation with file mapping
 */

/**
 * Physical label file returned by the carrier or produced by adapter processing
 * 
 * Represents an actual file artifact (PDF, ZPL, etc.) that can be stored, transmitted, or displayed.
 * Multiple parcels may reference the same file (e.g., single PDF with multiple labels).
 * 
 * **Binary Data Handling:**
 * 
 * Adapters should return label bytes via `rawCarrierResponse` in the parent `CreateLabelsResponse`,
 * NOT in this file object. This file object references the binary data by ID and metadata.
 * 
 * Pattern:
 * ```
 * CreateLabelsResponse {
 *   files: [
 *     { id: "file-1", contentType: "application/pdf", byteLength: 4096, ... }
 *   ],
 *   results: [
 *     { inputId: "parcel-1", fileId: "file-1", pageRange: { start: 1, end: 1 } }
 *   ],
 *   rawCarrierResponse: <Buffer ...> or { pdfBuffer: <Buffer ...> }  // ← Raw bytes here
 * }
 * ```
 * 
 * Integrators then:
 * 1. Extract `rawCarrierResponse` from the response
 * 2. Upload/store the bytes to their own storage (S3, database, etc.)
 * 3. Update each file's `url` field with the stored location
 * 4. Return the updated response to end users
 */
export interface LabelFileResource {
   /**
    * Unique identifier for this file (UUID, generated by adapter)
    * Used to link LabelResult items to their corresponding file(s)
    */
   id: string;

   /**
    * Optional direct URL to access the file
    * Could be a presigned URL, CDN URL, or temporary public URL
    * Integrators typically populate this after uploading `rawCarrierResponse` to storage
    * 
    * **Note:** Initially undefined; adapters do not provide URLs (keep them stateless).
    * Integrators populate this field during their storage/handling pipeline.
    */
   url?: string;

   /**
    * Optional inline data URL for small files
    * Format: data:application/pdf;base64,...
    * 
    * **Avoid:** Reserved for development/testing only. Production should use `url`.
    * Large labels should NOT be embedded here; use `rawCarrierResponse` instead.
    */
   dataUrl?: string;

   /**
    * MIME type of the file (e.g., "application/pdf", "application/x-zpl")
    * Derived from carrier response or adapter knowledge of format
    */
   contentType: string;

   /**
    * Size of the file in bytes (if known)
    * Helps integrators allocate storage and validate transfers
    */
   byteLength?: number;

   /**
    * Number of pages in the file (relevant for PDF)
    * Only populated if the adapter can determine page count from carrier or metadata
    */
   pages?: number;

   /**
    * Page orientation if known (e.g., portrait A7, landscape A6)
    */
   orientation?: 'portrait' | 'landscape';

   /**
    * Carrier-specific metadata (e.g., Foxpost size, testMode, compression)
    * Optional; populated only if relevant to the carrier
    */
   metadata?: Record<string, unknown>;

   /**
    * Checksum for integrity verification (e.g., SHA256 hex)
    * Optional; included if carrier provides or adapter calculates
    */
   checksum?: string;

   /**
    * ISO 8601 timestamp when this URL or file expires (if presigned/temporary)
    * Optional; only relevant for temporary URLs
    */
   expiresAt?: string;
}

/**
 * Per-parcel label result
 * Describes the outcome of label generation for a single input parcel
 * 
 * Maintains strict 1:1 correspondence with input parcel IDs (same order).
 * References files via fileId for carriers that produce one or many files.
 */
export interface LabelResult {
  /**
   * The input parcel carrier ID that was requested
   * Matches the request's parcelCarrierIds[i]
   */
  inputId: string;

  /**
   * Status of this label generation attempt
   * - 'created': label was generated successfully
   * - 'failed': label generation failed (see errors)
   * - 'skipped': label was skipped (e.g., carrier limitation)
   */
  status: 'created' | 'failed' | 'skipped';

  /**
   * Reference to LabelFileResource.id if status === 'created'
   * Multiple LabelResult items may reference the same fileId (single PDF with multiple labels)
   */
  fileId?: string;

  /**
   * Page range in the referenced file where this parcel's label(s) reside
   * Useful when file contains multiple pages and each label occupies one or more pages
   * Example: { start: 1, end: 1 } for single-page label, { start: 2, end: 2 } for second page
   */
  pageRange?: {
    start: number;
    end: number;
  };

  /**
   * Errors if status === 'failed'
   */
  errors?: Array<{
    code?: string;
    message: string;
    field?: string;
  }>;

  /**
   * Raw carrier response for this specific parcel (if available)
   */
  raw?: unknown;
}

/**
 * Batch label creation response
 * 
 * Returns:
 * - `files`: metadata about generated label files (IDs, content type, size, pages)
 * - `results`: per-input success/failure and file mapping
 * - `rawCarrierResponse`: the actual binary data (Buffer, PDF bytes, etc.)
 * - `summary`: overall success/failure counts
 * 
 * **Binary Data Pattern:**
 * 
 * Adapters PUT raw bytes into `rawCarrierResponse`, NOT into individual `LabelFileResource` objects.
 * This keeps adapters lightweight and stateless; integrators handle storage/URLs.
 * 
 * @example Foxpost (single PDF, multiple labels)
 * ```
 * {
 *   files: [{
 *     id: "uuid-1",
 *     contentType: "application/pdf",
 *     byteLength: 8192,
 *     pages: 3,
 *     orientation: "portrait",
 *     metadata: { size: "A7", testMode: true }
 *     // Note: url and dataUrl are undefined; integrator fills url after upload
 *   }],
 *   results: [
 *     { inputId: "CLFOX001", status: "created", fileId: "uuid-1", pageRange: { start: 1, end: 1 } },
 *     { inputId: "CLFOX002", status: "created", fileId: "uuid-1", pageRange: { start: 2, end: 2 } },
 *     { inputId: "CLFOX003", status: "created", fileId: "uuid-1", pageRange: { start: 3, end: 3 } }
 *   ],
 *   successCount: 3,
 *   failureCount: 0,
 *   totalCount: 3,
 *   allSucceeded: true,
 *   summary: "All 3 labels generated successfully",
 *   rawCarrierResponse: <Buffer ...>  // ← Raw PDF bytes from carrier
 * }
 * ```
 * 
 * Integrator flow:
 * ```typescript
 * const response = await adapter.createLabels(req, ctx);
 * 
 * // 1. Upload raw bytes
 * const url = await storage.upload(response.rawCarrierResponse, 'labels/batch-1.pdf');
 * 
 * // 2. Update file URLs
 * response.files?.forEach(file => {
 *   file.url = url;  // Or unique per-file URL if split
 * });
 * 
 * // 3. Return to client
 * return response;
 * ```
 * 
 * @example Multi-file carrier (hypothetical - each label is separate file)
 * ```
 * {
 *   files: [
 *     { id: "uuid-1", contentType: "application/pdf", byteLength: 4096, ... },
 *     { id: "uuid-2", contentType: "application/pdf", byteLength: 4096, ... }
 *   ],
 *   results: [
 *     { inputId: "PARCEL001", status: "created", fileId: "uuid-1" },
 *     { inputId: "PARCEL002", status: "created", fileId: "uuid-2" }
 *   ],
 *   successCount: 2,
 *   failureCount: 0,
 *   totalCount: 2,
 *   allSucceeded: true,
 *   summary: "All 2 labels generated successfully",
 *   rawCarrierResponse: { files: [<Buffer ...>, <Buffer ...>] }  // ← Adapter returns structure with all bytes
 * }
 * ```
 */
export interface CreateLabelsResponse {
   /**
    * Per-parcel results from the batch operation
    * One LabelResult per input parcelCarrierId, in the same order
    * Maintains strict 1:1 correspondence with request input
    */
   results: LabelResult[];

   /**
    * File artifacts metadata returned by adapter
    * Contains IDs, content type, size, page count, and orientation
    * Does NOT contain the actual binary data (see rawCarrierResponse instead)
    * 
    * Adapters populate: id, contentType, byteLength, pages, orientation, metadata
    * Integrators populate: url (after uploading rawCarrierResponse)
    * 
    * Optional: may be empty if all labels failed
    */
   files?: LabelFileResource[];

   /**
    * Number of labels that succeeded (status === 'created')
    */
   successCount: number;

   /**
    * Number of labels that failed (status === 'failed')
    */
   failureCount: number;

   /**
    * Total number of labels processed
    */
   totalCount: number;

   /**
    * Whether all labels succeeded
    * True only if failureCount === 0 && totalCount > 0
    */
   allSucceeded: boolean;

   /**
    * Whether all labels failed
    * True only if successCount === 0 && totalCount > 0
    */
   allFailed: boolean;

   /**
    * Whether operation had mixed results (some succeeded, some failed)
    * True only if successCount > 0 && failureCount > 0
    */
   someFailed: boolean;

   /**
    * Human-readable summary of the results
    * Examples:
    * - "All 5 labels generated successfully"
    * - "3 labels generated, 2 failed"
    * - "All labels failed"
    */
   summary: string;

   /**
    * **IMPORTANT:** Raw binary data or response from carrier
    * 
    * This is where adapters return the actual label bytes.
    * Integrators extract, store, and populate file URLs.
    * 
    * Content depends on carrier and adapter:
    * - Foxpost: `<Buffer>` (raw PDF bytes)
    * - DHL: `{ files: [<Buffer>, ...] }` (multiple PDFs)
    * - Other carriers: carrier-specific structure
    * 
    * Adapters MUST ensure this is serializable (Buffer → base64 if needed for some transports)
    * or provide clear documentation of the expected type for integrators.
    * 
    * Integrators are responsible for:
    * 1. Detecting/parsing the structure (if not just raw bytes)
    * 2. Uploading to storage (S3, database, file system, etc.)
    * 3. Updating `files[].url` with the storage location
    * 4. Returning updated response to clients
    */
   rawCarrierResponse?: unknown;
}
